package main

import (
	"fmt"
	"log"
	"os"
)

func getFieldType(field *DBSchema) string {

	//fmt.Printf("Getting type field %s\n", field.DataType)
	return "text"
}

func generate_Formly(formlyFile string) {

	f, err := os.Create(formlyFile)
	if err != nil {
		log.Fatalln("CreateFile:", formlyFile, err.Error())
	}
	defer f.Close()

	str := fmt.Sprintf(`// Code generated by codegen from SQL table %s
;(function(){

get%sFields = function() {

  return [`, sqltable, Tablename)

	// Now generate one block per field in the schema
	for i, field := range schema {
		if i == 0 {
			str += `{`
		} else {
			str += `    },{`
		}
		str += fmt.Sprintf(`
      name: '%s.%s',
      extends: 'lx-input',
      wrapper: 'lx-wrapper-errors',
      defaultOptions: {
        key: '%s',
        templateOptions: {
          type: '%s',
        }
      }
`,
			tablename,
			field.UpColumn,
			field.UpColumn,
			getFieldType(field),
		)
	}
	str += fmt.Sprintf(`  }] // end fields

} // get%sFields
`, Tablename)

	str += fmt.Sprintf(`
get%sForm = function(isNew) {

  return [`, Tablename)

	// Add a flex block for each field
	for i, field := range schema {
		if i == 0 {
			str += `{`
		} else {
			str += `  },{`
		}
		str += fmt.Sprintf(`
    type: 'lx-flex',
    templateOptions: {
      flex: { container: "row", item: "12"},
      fields: [
        {type: '%s.%s'},
      ]
    }
`, tablename, field.UpColumn)
	} // for range schema

	// End the blocks
	str += fmt.Sprintf(`
  }]
} // get%sForm

})();
`, Tablename)

	f.WriteString(str)
	f.Sync()
}
